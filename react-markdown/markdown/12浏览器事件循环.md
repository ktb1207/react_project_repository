### 浏览器事件循环机制

> 1. 单线程

js引擎采用单线程来执行javascript代码，javascript采用单线程工作的原因与它最早的设计初衷有关

最早javaScript这门语言单是一门运行在浏览器端的脚本语言，他的目的是为了实现页面上的动态交互。而实现页面交互的核心就是dom操作，这也就决定了他必须使用单线程模型，否则就会出现很复杂的线程同步问题。

可以设想一下，假定在javaScript中同时有多个线程工作，其中一个线程修改了某一个dom元素，而另外一个线程同时又删除了这个元素，此时浏览器就无法明确该以哪一个线程的工作结果为准。

为了避免这种线程同步的问题，从一开始javaScript就被设计成了单线程模式工作，这也就成为了这门语言最为核心的特性之一。

这里所说的单线程指的是在js的执行环境当中，负责执行代码的线程只有一个。

> 2. 同步模式和异步模式

为了解决耗时任务阻塞执行的问题，javaScript语言将任务的执行模式分成了两种。同步模式(Synchronous)和异步模式(Asynchronous)。

- 同步任务：对于同步任务而言，同步任务在调用栈从上到下依次执行。
- 异步任务：异步任务又分为 1.宏任务 2.微任务，异步任务会放在各自对应的`任务队列`中等待执行。

> 3. 事件循环流程

- 循环首先从宏任务开始执行
- 其次执行宏任务内部的同步任务，在同步任务执行过程中，产生的新的宏任务和微任务，会被各自存放各自任务队列，等待执行。
- 最后检查微任务队列是否有等待执行，有则全部依次执行，采用先进先出即先存放队列的微任务会被先执行，在微任务执行过程中，如过又产生了宏任务和微任务，同样各自存入队列，新加入的微任务会被一并执行
- 微任务队列被清空，检查红宏任务队列是否有等待被执行宏任务，开启下一轮循环。

浏览器为了能够使js的内部task(任务)与DOM任务有序的执行，会在前一个task执行完毕后并且在下一个task执行开始前，对页面进行重新渲染（render），这里说的task就是指宏任务。

> 4. 宏任务分类

- script(整体代码), setTimeout, setInterval, I/O(事件), XHR异步请求、 UI rendering;

> 5. 微任务分类

- async await Promise.then, Object.observe(已废弃), MutationObserver(html5新特性);

