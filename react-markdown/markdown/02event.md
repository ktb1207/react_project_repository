### 关于 React 事件系统笔记

> 1. 为什么提供合成事件？

因为 React 想实现一个全浏览器的框架， 为了实现这种目标就需要提供全浏览器一致性的事件系统，以此抹平不同浏览器的差异。

- 对原生事件进行封装
- 对某些原生事件的升级和改造
- 不同浏览器事件兼容的处理

> 2. 事件绑定机制

其主要依赖浏览器原生事件冒泡机制，将所有事件委托在了 document/root

> 3. 原生事件与合成事件执行关系

- 浏览器事件的执行需要经过三个阶段，捕获阶段-目标元素阶段-冒泡阶段。
- 同一节点同时绑定原生事件和合成事件，原生事件无论捕获或冒泡都先于合成事件执行，因为合成事件的执行需要冒泡到 document，再由事件统一派发。
- 原生事件阻止冒泡则会阻止合成事件执行。合成事件阻止冒泡，并不会阻止原生事件执行。

> 4. 合成事件-注册

- 组件挂载和更新阶段，解析 prop 并检查是否包含事件类型如 onClick, onMouseDown, 并找到合成事件依赖的顶层原生事件属性
- 检查 document 是否已注册对应原生事件的监听，如果之前已有对应原生事件注册，则忽略。否则在 document 注册对应原生事件并提供 dispatchEvent 函数。

> 5. 合成事件-存储

react 里所有事件的触发都是通过 dispatchEvent 方法统一进行派发,就需要将注册阶段解析 prop 得到的事件处理函数进行保存，以方便事件处理函数被派发执行。

react 把所有的事件和事件类型以及 react 组件进行关联，把这个关系保存在了一个 map 里，也就是一个对象里（键值对），然后在事件触发的时候去根据当前的组件 id 和事件类型查找到对应的事件 fn。

- react dom ，事件类型，处理函数 fn 放入数组存储
  ```js
  {
    click: [fn1, fn2, fn3],
    change: [fn1, fn2, fn3]
  }
  ```

> 6. 合成事件-触发

有了上面的合成事件注册与存储，那么当用户操作触发某一个事件操作，通过事件冒泡机制最后由 document 捕获。将进行事件的统一派发执行。

- 任一事件触发，执行 dispatchEvent 函数。
- dispatchEvent 执行 batchedEventUpdates(handleTopLevel)， batchedEventUpdates 会打开批量渲染开关并调用 handleTopLevel
- handleTopLevel 会依次执行 plugins 里所有的事件插件。
- 如果一个插件检测到自己需要处理的事件类型时，则处理该事件。
- 从点击的原生事件中找到对应 DOM 节点，从 DOM 节点中找到一个最近的 React 组件实例， 从而找到了一条由这个实例父节点不断向上组成的链
- 反向触发这条链，父-> 子，模拟捕获阶段，触发所有 props 中含有 onClickCapture 的实例。
- 正向触发这条链，子-> 父，模拟冒泡阶段，触发所有 props 中含有 onClick 的实例。

`说明`：

- onClick 和 onClickCapture 均是冒泡阶段执行，onClickCapture 只是 react 合成事件模拟事件捕获
- 事件只针对原生组件生效，自定义组件不会触发 onClick
- 合成事件触发会打开批量渲染开关，这个开关会将所有的事件处理函数内部 setState 变成异步函数
- React 的冒泡和捕获并不是真正 DOM 级别的冒泡和捕获
- React 的合成事件只能在事件周期内使用，因为这个对象很可能被其他阶段复用，如果想持久化需要手动调用 event.persist() 告诉 React 这个对象需要持久化。( React17 中被废弃)
